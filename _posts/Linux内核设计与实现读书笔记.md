#Linux内核设计与实现读书笔记

---
###虚拟处理器和虚拟内存
现代操作系统中，进程提供两种虚拟机制：虚拟处理器和虚拟内存，
* 虚拟处理器：虽然实际上可能是许多进程正在分享一个处理器，但虚拟处理器给进程一种假象，让这些进程觉得自己在独享处理器；
* 虚拟内存：让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源;

同一个进程中的线程可以共享虚拟内存，但每个进程都有各自的虚拟处理器。  

---
###OS区分用户态与内核态的好处
1、安全；CPU一些指令是非常危险的，如果错用将导致系统崩溃，比如设置时钟等，CPU将指令分为特权指令及非特权指令，对于那些危险的指令，只允许os及其相关模块使用；Intel的CPU将特权级别分为4个级别：RING0,RING1,RING2,RING3。linux处于用户态时，处理器在特权级最低的（3级）用户代码中运行，处于内核态时，处理器处于特权级最高的（0级）内核代码中执行。  

2、屏蔽底层硬件设备的复杂性，提供给上层统一的系统调用。  

由用户态切换到内核态的三种方式：
* 系统调用
* 中断
* 异常

---
###linux中的中断处理
中断由硬件设备发向处理器，处理器接收到中断后，会马上向操作系统反应此信号的到来，然后就由操作系统负责处理这些新到来的数据，中断可以随时产生，内核随时可能因为新到来的中断而被打断。  

操作系统通过中断向量表区分不同设备产生的中断，从而提供不同的中断处理程序。  

硬件发出的中断不能打断当前指令的执行，但异常可以。异常由处理器发出，常见的异常可以包含缺页异常、通过软中断执行系统调用产生的异常。

---
###进程描述符相关
1. PID最大值默认设置为32768，这个最大值实际上就是系统中允许同时存在的进程的最大数目。  
2. 尽管32768对于一般的桌面系统足够用了，但大型服务器可能需要更多进程，这个值越小，转一圈就越快，如果确实需要的话，可以通过修改/proc/sys/kernel/pid_max来提高上限。
3. 进程描述符中的state域描述了进程的当前状态。系统中的每个进程都必然处于五种进程状态中的一种，该域的值也必为下列五种状态标志之一：  
* TASK_RUNNING(处于运行队列)：————进程是可执行的；它或者正在执行，或者在**运行队列**中等待执行。**ps命令进程状态显示为R；**
* TASK_INTERRUPTIBLE(可中断):————进程正在睡眠(也就是说它被阻塞)，等待某些条件的达成。进程此时处于**等待队列**；一旦这些条件达成，内核就会把进程状态设置为运行。处于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行。**什么时候进程会处于TASK_INTERRUPTIBLE状态呢？ps命令进程状态显示为S；**
* TASK_UNINTERRUPTIBLE(不可中断):————除了就算是接收到信号也不会被唤醒或准备投入运行外，这个状态与可打断状态相同。进程在这个状态时也处于**等待队列**；这个状态通常在进程必须在等待时不受干扰或等待事件很快就会发生时出现。由于此状态的进程对信号不做响应，所以较之可中断状态，使用的较少。**ps命令进程状态为D的就处于这种不可中断的睡眠状态，一般由IO引起，同步IO在做读或写操作时，cpu不能做其它事情，只能等待，这时进程处于这种状态，如果程序采用异步IO，这种状态应该就很少见到了**处于这个状态的进程等待的资源一般很快能得到满足，通过ps查看的进程一般不应该处于这个状态；如果ps查看的进程处于这个状态，那么一般是这个进程等待的资源不可满足所导致的。  
* TASK_TRACED：————被其它进程跟踪的进程，例如通过ptrace对调试程序进行跟踪。**ps命令进程状态为T的可能处于这种状态;**
* TASK_STOPPED：————进程停止执行；没有投入运行也不能投入运行。通常这种状态发生在接收到SIGSTOP、SIGTSTP等信号的时候。**ps命令进程状态为T的也可能处于这种状态;**处于TASK_STOPPED状态的进程可以通过向其发送SIGCONT信号恢复到TASK_RUNNING状态，仍存在后台；
* TASK_ZOMBIE:————进程处于僵尸状态；进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放，**ps命令进程状态为Z的就处于这种状态;**
* ctrl + c(SIGINT信号):中断处理程序中直接杀死进程，回收其资源，可忽略；SIGSTOP相当于Ctrl + Z，可以继续恢复到前台执行；

**问题**：只有处于Running状态的线程才占用CPU吗？？？  
linux系统中大部分进程都处于TASK_INTERRUPTIBLE状态，(比如一个C语言serverSocket.accept()的进程就处于TASK_INTERRUPTIBLE状态)；进程何时会由运行态变为TASK_INTERRUPTIBLE状态呢？何时又会重新切换到就绪运行态呢？  

---
###进程调度的几种情况

**进程调度的几种情况：**1、时间片耗尽 2、高优先级进程抢占(比如一个阻塞的进程被唤醒，并且被唤醒的进程比正在运行的进程的优先级高，则有可能发生抢占) 3、进程主动放弃CPU  4、进程由于等待的资源得不到进入TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE状态、由于收到SIGSTOP信号进入TASK_STOPPED状态时都会触发进程调度

**os是如何确定调度之前的正在运行的进程是应该进入就绪队列还是进入等待队列还是进入挂起队列呢？**  
  
我觉得应该是通过触发进程调度的方式来区分的，比如触发调度的方式是上述的1、2、3，则会进入就绪队列；如果是由于要获取的资源得不到，则进入等待队列(也就是阻塞队列)；如果是由于收到SIGSTOP信号则进入挂起队列；  

当阻塞队列中的进程等待的资源到位，os会通过中断或是发出wake_up()信号的方式唤醒被阻塞的进程，使其重新被加入到就绪队列；当处于TASK_STOPPED状态的进程收到信号SIG_CONT或是wake_up()时，会重新进入到就绪队列。  

<img src="/img/otherblog/Linux_Process_Change.jpg" width="500" height="500" alt="Linux进程状态转换" />
<center>图1：Linux进程状态转换图</center>   

---
###linux中的用户线程与内核线程
比如用户线程在用户空间中调用了C语言的API进行read读磁盘文件操作，c语言的API最终调用的也是read()系统调用，在调用这个系统调用时会指定read()系统调用返回的数据在用户空间中存放的起始地址，用户线程通过触发int0x80软中断导致系统切换到内核态导致系统切换到内核态并触发128号异常处理程序，即系统调用对应的处理程序；此系统调用处理程序执行时就相当于一个内核线程，其作用就是根据用户传入的系统调用号调用内核中的系统调用函数相关代码并将结果返回到用户指定的地址空间中；试想如果系统调用处理程序由于执行内核中的read系统调用函数陷入阻塞状态，则此用户线程与其对应的内核线程均陷入阻塞状态；

当内核线程陷入阻塞的时候(比如由于调用read系统调用陷入阻塞)，是可以被其它的内核线程抢占的。  

为什么说linux进程调度是基于内核线程执行的呢？因为进程切换时，进程总是处于内核空间，此时实际被执行的是用户进程对应的内核线程程序，所以linux进程调度实际是基于内核线程程序执行的；

比如一个正在执行的用户进程每次响应时钟中断如果不在内核态都会陷入内核态，在内核态由其对应的内核线程执行时钟中断对应的中断处理程序，如果检测到此进程时间片用完，则切换到下一个进程开始执行；

所以每一个用户进程对应一个内核线程的好处是：1、一个用户线程被阻塞时不至于阻塞所有的线程；2、线程调度直接使用os的线程调度策略就可以。  

**为什么轻量级进程需要有对应的内核线程呢？**  

用户级线程在调用核心服务时（如文件读写），需要“捆绑（bound）”在一个lwp上。永久捆绑（一个LWP固定被一个用户级线程占用，该LWP移到LWP池之外）和临时捆绑（从LWP池中临时分配一个未被占用的LWP）。在调用系统服务时，如果所有LWP已被其他用户级线程所占用（捆绑），则该线程阻塞直到有可用的LWP。如果LWP执行系统线程时阻塞（如read()调用），则当前捆绑在LWP上的用户级线程也阻塞。  

**处理器总处于以下状态中的一种：**  

* 内核态，运行于进程上下文，内核代表进程运行于内核空间；比如处理系统调用；内核代表进程运行于内核空间时是有可能阻塞的，比如调用read()系统调用一直不能返回；此时与此内核进程对应的用户进程也处于阻塞状态；说当一个程序执行了系统调用(实际也是通过软中断实现的)或者触发某个异常（软中断），此时就会陷入内核空间，内核此时代表进程执行，并处于进程上下文中。  

* 内核态，运行于中断上下文，内核代表硬件运行于内核空间；比如响应设备中断；中断时，内核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一般不会阻塞。

* 用户态，运行于用户空间。

**用户线程与内核线程的对应关系(LWP与内核线程始终是一对一对应关系)**
* 一对一：一个用户线程对应一个LWP对应一个内核线程
* 多对一：多个用户线程对应一个LWP对应一个内核线程
* 多对多：比如3个用户线程对应2个LWP对应两个内核线程

**内核抢占与用户抢占**

抢先占用的触发:

1)当一个进程因为它的时间片用完而被内核停止执行时,就说这个进程被抢占.
2)当一个享有更高优先级的进程在就绪队列,内核同样可以抢占正在执行的进程,即使它的时间片还没用完.

---
###Java多线程实现相关问题
1. 一个java线程映射到linux的一个内核线程吗？最多可以产生多少个java线程？
2. java线程状态与linux进程五种状态的对比？
3. java线程在IO阻塞、Synchronized阻塞时的线程状态转换是通过os实现的吗？
4. java Thread.sleep()导致线程状态时如何转换的，底层的实现原理是什么呢？
5. java运行时数据区与java内存模型？
  