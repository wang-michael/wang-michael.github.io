#Java并发程序设计读书笔记

---
###JSR相关问题
**JSR133规范：**它描述了用Java语言编写的多线程程序的语义；包括多线程更新共享内存时，读操作能看到什么值的规则，这些语义不会去描述多线程程序该如何执行。而是描述多线程程序允许表现出的行为。任何执行策略，只要产生的是允许的行为，那它就是一个可接受的执行策略。  

**程序是否被正确的同步了：**理解一个程序是否被正确的同步了，有两个关键概念：
* 冲突访问（Conflicting Accesses）：对同一个共享字段或数组元素存在两个访问（读或写），且至少有一个访问是写操作，就称作有冲突。
* Happens-Before关系 ：两个动作（action）可以被happens-before关系排序。如果一个动作happens-before另一个动作，则第一个对第二个可见，且第一个排在第二个之前。

**当程序包含两个没有被happens-before关系排序的冲突访问时，就称存在数据争用。正确同步的程序是没有数据争用的程序。**  

JSR-133规范规定从JSR-133内存模型开始，仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-133中都必须具有原子性(即任意读操作必须要在单个读事务中执行)。  

**导致程序出现可见性问题的原因有：**
* 缓存优化或者硬件优化导致一个线程对变量的更新另一个线程不能及时看到
* 指令重排序

---
###JMM相关问题
**JMM定义：**解决共享变量的内存可见性问题，规定了一个线程对共享变量的写操作何时会对另一个线程可见。两个操作A、B，如果A happens-before B，那么如果A先对共享变量做了写操作，B中一定是可见的。      
  
**JMM需要解决的问题包含原子性问题和可见性问题：**
* 原子性问题：对于非原子类型的操作，如果并发操作时不做适当的控制，就可能会出问题。比如count++，long和double类型在32位机器上的写操作等。我们针对非原子操作所做的并发控制是基于happens-before规则建立的，比如将共享的long和double变量声明为volatile保障对其读写的原子性，使用synchronized关键字包装count++操作等等。    
* 可见性问题：可能由于两种原因导致，**一是**由于编译器优化或者硬件优化缓存导致。比如CPU1上的线程对某个共享变量t进行了优化，对其进行缓存；如果在CPU2上的某个线程修改了变量t的实际值，那么CPU1上的线程可能无法及时的读取到这个被更改后的值。**二是**由于指令重排序导致的可见性问题。**对于这两种可见性问题**，可以基于happens-before操作对其进行并发控制解决。

**指令重排序问题的进一步解释：**重排序可分为以下三种类型
* 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
* 指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
* 内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

比如以下代码：  
```java
Processor A:

a = 1; // A1
x = b; // A2

Processor B:

b = 2; // B1
y = a; // B2

初始状态：a = b = 0;
```
假设处理器A和处理器B按程序的顺序并行执行内存访问，最终可能得到 x = y = 0 的结果。   

**问题：**Volatile加在对象引用上是何意义呢？  
Volatile对象引用仅能保证对于这个引用的更新在各个线程中是实时可见的，而对于对象引用中包含的其它域，更新是否实时可见取决于这些域是否使用final或者Vloatile修饰，具体可参考：[Do I need volatile for variables of reference types, too?
](https://stackoverflow.com/questions/7075517/do-i-need-volatile-for-variables-of-reference-types-too)，[volatile是否能保证数组中元素的可见性？](http://ifeve.com/volatile-array-visiblity/)，[CON50-J. Do not assume that declaring a reference volatile guarantees safe publication of the members of the referenced object
](https://wiki.sei.cmu.edu/confluence/display/java/CON50-J.+Do+not+assume+that+declaring+a+reference+volatile+guarantees+safe+publication+of+the+members+of+the+referenced+object#space-menu-link-content)

---
###happens-before相关：
A操作与B操作之间存在happens-before关系，如果指令重排序后的执行结果与A、B操作按照happens-before顺序执行操作结果一致的话，这种指令重排序操作就被认为是合法的。换句话说，**指令重排序必须在不影响happens-before关系的情况下进行。**


**几条基本原则的理解：**
  
* 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。两个操作之间满足这个规则规定的happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！换句话说，在不影响程序执行结果的条件下，指令重排序可能使得满足happens-before这个规则的两个操作前一个操作反而在后一个操作之后执行。比如计算圆面积：
```java
double pi = 3.14; // A
double r = 1.0;  // B 
double area = pi * r * r; // C
```
   由于A、C，B、C间均存在数据依赖关系，因此在最终的指令执行序列中，C不可能重排序到A、B的前面。但A、B之间不存在数据依赖关系，A虽然happens-before与B，但A操作的执行是可以后于B操作的执行的。  
   通常数据依赖关系分为三种类型，**写后读，读后写，写后写**；有数据依赖的两个操作其执行顺序必须按照程序中的顺序来，是不能被指令重排序改变的。**需要注意的是，数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。**

   除了数据依赖，还有一种依赖种类叫做控制依赖，在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果，但多线程中对存在控制依赖的操作重排序，可能会改变程序的执行结果。  
```java
if(flag) { // 3
    int i = a * a; // 4
}

// 重排序后可能变为：  

temp = a * a;

if(flag) {
    int i = temp;
}
```  
* Volatile规则：

**问题：**两个动作之间存在happens-before关系并不意味着这些动作在Java中必须以这种顺序发生。为什么呢？？？happens-before关系主要用于强调两个有冲突的动作之间的顺序，以及定义数据争用的发生时机。

---
### 宏观上谈锁：乐观锁与悲观锁
锁从宏观上分类，分为悲观锁与乐观锁。

#### 乐观锁
乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。

java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。  

#### 悲观锁
悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。

从两个方面举例：Synchronized及RetreenLock；

JDK1.6之前，Synchronized属于悲观锁，JDK1.6之后对其进行了优化，采用了先乐观再悲观的形式；

RetreenLock乐观悲观介绍？

### Synchronized实现原理
JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，两种同步方式都可以通过使用monitorenter和monitorexit指令来实现。JVM保证每个monitorenter必须有对应的monitorexit与之配对。任何一个对象都有一个monitor与之关联，当一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。  

**JavaSE 1.6中为了减少获得锁和释放锁带来的性能消耗，引入了"偏向锁"和"轻量级锁"，在JavaSE 1.6中，锁一共有四种状态：无锁、偏向锁、轻量级锁，重量级锁。锁可以升级而不可以降级，比如偏向锁升级为轻量级锁之后不能再降级成偏向锁。这种可升级而不能降级的策略目的是为了提高获得锁和释放锁的效率。**

需要注意的是偏向锁、轻量级锁、重量级锁之间只能升级，不能降级；但这几种状态都可以降级为无锁状态。  

### 为什么会存在偏向锁呢？
HotSpot的作者经过研究发现，大多数情况下，**锁不仅不存在多线程竞争，而且总是由同一线程多次获得，**为了让线程获得锁的代价更低而引入了偏向锁。**偏向锁是如何减少线程获得锁的代价的呢？**原来是通过避免已经获得锁的线程重复使用CAS操作来加锁和解锁来实现的。线程在进出同步块时只需简单的测试下对象头的markword字段中是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，无需再进行多余的CAS操作。  

**偏向锁使用了一种等到竞争才释放所的机制，持有偏向锁的线程退出同步块时并不会默认释放偏向锁**所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。这时持有偏向锁的线程可能死亡，可能活动，也可能不活动。
* 如果线程不处于活动状态，偏向锁撤销时有可能先恢复到无锁状态，再由其他线程竞争此对象时加锁；
* 如果线程仍然活动，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。  

可以通过JVM参数设置来调整是否开启偏向锁。  

总结：线程获得锁的过程：1、判断锁对象的markword中是否存储着指向当前线程的偏向锁。如不存在则转2； 2、测试下markword中偏向锁的标识是否设置为1，如果为1，表示当前对象上含有偏向锁，则尝试使用CAS将对象头中的偏向锁指向当前线程。 3、若当前锁对象上不含偏向锁，则直接使用CAS操作竞争锁。  

**问题:**非偏向锁(轻量级锁、重量级锁)是在进入同步块时加锁，退出同步块时解锁吗？？？
**问题:**锁不能降级什么意思？比如本次一个线程进入同步快时获得了锁对象的轻量级锁，同步块执行之后解锁；下次再对锁对象加锁，至少为轻量级锁，不能从偏向锁开始吗？ 什么时候锁会降级呢？？？