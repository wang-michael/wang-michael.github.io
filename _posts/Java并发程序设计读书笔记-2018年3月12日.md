#Java并发程序设计读书笔记

---
###JSR相关问题
**JSR133规范：**它描述了用Java语言编写的多线程程序的语义；包括多线程更新共享内存时，读操作能看到什么值的规则，这些语义不会去描述多线程程序该如何执行。而是描述多线程程序允许表现出的行为。任何执行策略，只要产生的是允许的行为，那它就是一个可接受的执行策略。  

**程序是否被正确的同步了：**理解一个程序是否被正确的同步了，有两个关键概念：
* 冲突访问（Conflicting Accesses）：对同一个共享字段或数组元素存在两个访问（读或写），且至少有一个访问是写操作，就称作有冲突。
* Happens-Before关系 ：两个动作（action）可以被happens-before关系排序。如果一个动作happens-before另一个动作，则第一个对第二个可见，且第一个排在第二个之前。

**当程序包含两个没有被happens-before关系排序的冲突访问时，就称存在数据争用。正确同步的程序是没有数据争用的程序。**  

JSR-133规范规定从JSR-133内存模型开始，仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-133中都必须具有原子性(即任意读操作必须要在单个读事务中执行)。  

**导致程序出现可见性问题的原因有：**
* 缓存优化或者硬件优化导致一个线程对变量的更新另一个线程不能及时看到
* 指令重排序

---
###JMM相关问题
**JMM定义：**解决共享变量的内存可见性问题，规定了一个线程对共享变量的写操作何时会对另一个线程可见。两个操作A、B，如果A happens-before B，那么如果A先对共享变量做了写操作，B中一定是可见的。      
  
**JMM需要解决的问题包含原子性问题和可见性问题：**
* 原子性问题：对于非原子类型的操作，如果并发操作时不做适当的控制，就可能会出问题。比如count++，long和double类型在32位机器上的写操作等。我们针对非原子操作所做的并发控制是基于happens-before规则建立的，比如将共享的long和double变量声明为volatile保障对其读写的原子性，使用synchronized关键字包装count++操作等等。    
* 可见性问题：可能由于两种原因导致，**一是**由于编译器优化或者硬件优化缓存导致。比如CPU1上的线程对某个共享变量t进行了优化，对其进行缓存；如果在CPU2上的某个线程修改了变量t的实际值，那么CPU1上的线程可能无法及时的读取到这个被更改后的值。**二是**由于指令重排序导致的可见性问题。**对于这两种可见性问题**，可以基于happens-before操作对其进行并发控制解决。

**指令重排序问题的进一步解释：**重排序可分为以下三种类型
* 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
* 指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
* 内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

比如以下代码：  
```java
Processor A:

a = 1; // A1
x = b; // A2

Processor B:

b = 2; // B1
y = a; // B2

初始状态：a = b = 0;
```
假设处理器A和处理器B按程序的顺序并行执行内存访问，最终可能得到 x = y = 0 的结果。   

**问题：**Volatile加在对象引用上是何意义呢？  
Volatile对象引用仅能保证对于这个引用的更新在各个线程中是实时可见的，而对于对象引用中包含的其它域，更新是否实时可见取决于这些域是否使用final或者Vloatile修饰，具体可参考：[Do I need volatile for variables of reference types, too?
](https://stackoverflow.com/questions/7075517/do-i-need-volatile-for-variables-of-reference-types-too)，[volatile是否能保证数组中元素的可见性？](http://ifeve.com/volatile-array-visiblity/)，[CON50-J. Do not assume that declaring a reference volatile guarantees safe publication of the members of the referenced object
](https://wiki.sei.cmu.edu/confluence/display/java/CON50-J.+Do+not+assume+that+declaring+a+reference+volatile+guarantees+safe+publication+of+the+members+of+the+referenced+object#space-menu-link-content)

---
###happens-before相关：
A操作与B操作之间存在happens-before关系，如果指令重排序后的执行结果与A、B操作按照happens-before顺序执行操作结果一致的话，这种指令重排序操作就被认为是合法的。换句话说，**指令重排序必须在不影响happens-before关系的情况下进行。**


**几条基本原则的理解：**
  
* 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。两个操作之间满足这个规则规定的happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！换句话说，在不影响程序执行结果的条件下，指令重排序可能使得满足happens-before这个规则的两个操作前一个操作反而在后一个操作之后执行。比如计算圆面积：
```java
double pi = 3.14; // A
double r = 1.0;  // B 
double area = pi * r * r; // C
```
   由于A、C，B、C间均存在数据依赖关系，因此在最终的指令执行序列中，C不可能重排序到A、B的前面。但A、B之间不存在数据依赖关系，A虽然happens-before与B，但A操作的执行是可以后于B操作的执行的。  
   通常数据依赖关系分为三种类型，**写后读，读后写，写后写**；有数据依赖的两个操作其执行顺序必须按照程序中的顺序来，是不能被指令重排序改变的。**需要注意的是，数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。**

   除了数据依赖，还有一种依赖种类叫做控制依赖，在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果，但多线程中对存在控制依赖的操作重排序，可能会改变程序的执行结果。  
```java
if(flag) { // 3
    int i = a * a; // 4
}

// 重排序后可能变为：  

temp = a * a;

if(flag) {
    int i = temp;
}
```  
* Volatile规则：

**问题：**两个动作之间存在happens-before关系并不意味着这些动作在Java中必须以这种顺序发生。为什么呢？？？happens-before关系主要用于强调两个有冲突的动作之间的顺序，以及定义数据争用的发生时机。
