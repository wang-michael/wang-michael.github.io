---
layout:     post
title:      网络编程相关知识杂记之二
date:       2017-12-31
author:     W-M
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - Java基础
---

本文主要记录了个人在学习网络编程相关知识时遇到的问题及自己的思考，主要用于备忘，错误难免，敬请指出！  
_ _ _  
### **UDP编程相关**  
&emsp;&emsp;使用UDP发送数据与接收数据大致可分为两个步骤，以发送数据为例：  
&emsp;&emsp;UDP因为是不可靠连接，发送数据时，应用进程中的数据在沿协议栈向下传递时，以某种形式拷贝到内核缓冲区，当数据链路层把数据传出后就把内核缓冲区中数据拷贝删除。写UDP套接口的write返回表示应用程序的数据或数据分片已经进入链路层的输出队列，如果输出队列没有足够的空间存放数据，将返回错误ENOBUFS。 
   
&emsp;&emsp;UDP接收数据时，通过 cat /proc/sys/net/core/rmem_default 和cat /proc/sys/net/core/rmem_max可以查看UDP socket缓冲区的缺省值和最大值。如果socket缓冲区满了，应用程序没来得及处理在缓冲区中的UDP包，那么后续来的UDP包会被内核丢弃，造成丢包。在socket缓冲区满造成丢包的情况下，可以通过增大缓冲区的方法来缓解UDP丢包问题。但是，如果服务已经过载了，简单的增大缓冲区并不能解决问题，反而会造成滚雪球效应，造成请求全部超时，服务不可用。

&emsp;&emsp;**UDP数据包的发送和接收问题**  
* UDP的通信有界性
在阻塞模式下，UDP的通信是以数据包作为界限的，即使server端的缓冲区再大也要按照client发包的次数来多次接收数据包，server只能一次一次的接收，client发送多少次，server就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收。

* UDP数据包的无序性和非可靠性
client依次发送1、2、3三个UDP数据包，server端先后调用3次接收函数，可能会依次收到3、2、1次序的数据包，收包可能是1、2、3的任意排列组合，也可能丢失一个或多个数据包。

* UDP数据包的接收
client发送两次UDP数据，第一次 500字节，第二次300字节，server端阻塞模式下接包，第一次recvfrom(1000)，收到是 1000，还是500，还是300，还是其他？
由于UDP通信的有界性，接收到只能是500或300，又由于UDP的无序性和非可靠性，接收到可能是300，也可能是500，也可能一直阻塞在recvfrom调用上，直到超时返回(也就是什么也收不到)。
在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，server端阻塞模式下接包，先后三次调用：recvfrom(200)，recvfrom(1000)，recvfrom(1000)，接收情况如何呢？
由于UDP通信的有界性，第一次recvfrom(200)将接收第一个500字节的数据包，但是因为用户空间buf只有200字节，于是只会返回前面200字节，剩下300字节将丢弃。第二次recvfrom(1000)将返回300字节，第三次recvfrom(1000)将会阻塞。  

* UDP包分片问题
如果MTU是1500，Client发送一个8000字节大小的UDP包，那么Server端阻塞模式下接包，在不丢包的情况下，recvfrom(9000)是收到1500，还是8000。如果某个IP分片丢失了，recvfrom(9000)，又返回什么呢？
根据UDP通信的有界性，在buf足够大的情况下，接收到的一定是一个完整的数据包，UDP数据在下层的分片和组片问题由IP层来处理，提交到UDP传输层一定是一个完整的UDP包，那么recvfrom(9000)将返回8000。如果某个IP分片丢失，udp里有个CRC检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以UDP是不可靠的传输协议，那么recvfrom(9000)将阻塞。

&emsp;&emsp;更多关于UDP数据包发送接收问题，可参考：[告知你不为人知的UDP-疑难杂症和使用](https://zhuanlan.zhihu.com/p/25622691)
&emsp;&emsp;问题：UDP客户端同时给多个服务端发数据，占用的是客户端的一个端口号还是多个端口号？  
&emsp;&emsp;问题：Java UDP的write方法是阻塞的吗？当发送缓冲区满的时候，Java UDP是选择阻塞等待数据发送完成，还是直接返回错误ENOBUFS，不管数据是否丢失？  
&emsp;&emsp;UDP发送数据时进程阻塞仅是由于需要把待发送数据从用户空间拷贝到内核空间，如果此时UDP输出队列没有足够的空间存放数据，会直接返回错误ENOBUFS，不会阻塞write调用吗？    
&emsp;&emsp;问题：Java UDP中在操作系统内核中确实既存在发送缓冲区又存在接收缓冲区吗？   
&emsp;&emsp;问题：如何在程序中设置UDP发送缓冲区与接收缓冲区大小？  

_ _ _  
### **TCP编程相关**   
#### **Socket究竟是什么？** 
Socket就是基于TCP/IP协议的编程模型，是TCP的应用层编程接口API，通过它应用层就可以访问TCP提供的服务。windows版JDK1.8中Socket类中相关操作实际是通过SocketImpl类实现的，SocketImpl类包含的成员变量如下：  
```java
public abstract class SocketImpl implements SocketOptions {
    //The file descriptor object for this socket.
    protected FileDescriptor fd;

    //The IP address of the remote end of this socket.
    protected InetAddress address;

    //The port number on the remote host to which this socket is connected.
    protected int port;

    //The local port number to which this socket is connected.
    protected int localport;
}
```    
可见对于每个SocketImpl子类的对象，其中均包含这几个变量，基于socket进行的connect、read、write等操作实际上都是在这几个成员变量的基础上进行的。  
<img src="/img/2017-12-31/SocketImplUML.jpg" width="600" height="600" alt="SocketImpl UML图" />
<center>图1：windows版JDK1.8中SocketImpl UML图</center>

#### **Socket Connect操作**
Socket Connect连接建立的过程实际就是与服务器端进行三次握手的过程，connect()方法是阻塞的，可能阻塞在等待服务器响应syn发回syn+ack数据包的过程中。 常见的客户端与服务器建立连接方式有两种：
```java
Socket s = new Socket(String host, String port);
```
或者
```java
Socket s = new Socket();
SocketAddress socketAddress = new InetSocketAddress(serverIp, port);
s.connect(socketAddress, timeout);//超时时间以ms为单位
```
上面的方式默认永不超时，直到客户端发现连接无法建立抛出异常；下面的方式在创建连接时可以指定超时时间，当超过指定时间连接还未建立，就会抛出异常停止尝试建立连接，当然，也有可能还未达到我们设置的timeout时间即抛出异常超时。什么情况下有可能抛出连接建立超时异常呢？  
* 由于网络的问题，TCP/IP三次握手时间>timeout的设置时间。这在国外访问weibo时，并且网络环境极差的情况下有可能发生。解决的办法：调大socket.connect方法中的timeout参数值，比如50s，linux默认最高是70s，如果超过70s没有意义，linux会采用70s。但是当调大之后，发现还是不到10s就报timeout exception。并且通过国外的机器ping api.weibo.com发现unreachable。说明客户端在传输层之下的网络层就发现连个Syn的报文都发不出去，更不用说三次握手了，客户端不用等到我们设置的timeout超时，直接失败并抛timeout exception。经验：在connection timeout诊断的第一步应该是ping一下确认网络层没有问题。注：客户端设置了timeout，但并不会等到超时才返回异常。客户端只要第一时间发现连接失败，就会抛timeout exception。
* 如果timeout设置的时间足够，但是由于服务器端的处理能力较差，比如缓冲连接队列较小，而应用层的处理能力没有连接缓冲快，导致缓冲连接占满，而拒绝新的连接。在服务端因为连接队列占满而拒绝服务的期间，客户端通过TCP协议重试连接三次。每次的时间翻倍。如果三次时间的累加<timeout参数值且能连接上，属于正常情况，表示队列腾出空位放当前连接。如果三次时间的累加<timeout参数值且未能连接上，则客户端会立刻抛出timeout exception,而不是等到timeout到期才抛。**需要注意的是服务端通过ServerSocket.accept()从缓冲连接队列中取出连接，在服务器将连接从缓冲队列取出之前，三次握手后的连接都在缓冲队列中保存。**只要客户端与服务端三次握手建立完成，客户端就可以向服务器发送数据，即使服务器没有将此客户端连接从缓冲连接队列中取出，客户端发送的数据也不会丢失。  

下面从以第一种方式new Socket(String host, String port)基于Socket类相关源码来分析连接建立过程，第二种方式原理与之大致相同。
```java
public Socket(String host, int port) throws UnknownHostException, IOException
{
	//若输入的host是域名，则根据DNS进行域名查找的过程是阻塞的
    this(host != null ? new InetSocketAddress(host, port) :
         new InetSocketAddress(InetAddress.getByName(null), port),
         (SocketAddress) null, true);
}
private Socket(SocketAddress address, SocketAddress localAddr,
                   boolean stream) throws IOException {
	//设置socket的实际实现，为什么不直接在socket方法中实现，而是又添加一层socketImpl外包装呢？
	//因为socket可以有许多种不同实现，使用socketImpl通过多态可灵活切换不同实现，相比于将不同实现方式都写在socket类中更清晰易懂
    setImpl();

    // backward compatibility
    if (address == null)
        throw new NullPointerException();

    try {
		//在本地调用操作系统TCP/IP相关API为socket创建相应文件描述符
        createImpl(stream);
		//为socket绑定相应的本地端口
        if (localAddr != null)
            bind(localAddr);
		//如果创建socket时候并没有指定本地端口，则会在connect方法中自动指定使用的端口
		//connect方法会尝试与远程服务器进行三次握手建立连接，可能阻塞
        connect(address);
    } catch (IOException | IllegalArgumentException | SecurityException e) {
        try {
            close();
        } catch (IOException ce) {
            e.addSuppressed(ce);
        }
        throw e;
    }
}
void setImpl() {
    if (factory != null) {
        impl = factory.createSocketImpl();
        checkOldImpl();
    } else {
        // No need to do a checkOldImpl() here, we know it's an up to date
        // SocketImpl!
        impl = new SocksSocketImpl();
    }
    if (impl != null)
        impl.setSocket(this);
}
//问：java.net.socket的createImpl方法还能用于创建UDP实现呢？
//@param stream a {@code boolean} value : {@code true} for a TCP socket, {@code false} for UDP.
void createImpl(boolean stream) throws SocketException {
    if (impl == null)
        setImpl();
    try {
        impl.create(stream);
        created = true;
    } catch (IOException e) {
        throw new SocketException(e.getMessage());
    }
}
/**AbstractPlainSocketImpl类doConnect方法是实现socket连接的主要操作，JDK官方文档中对其描述如下：
 * The workhorse of the connection operation.  Tries several times to
 * establish a connection to the given <host, port>.  If unsuccessful,
 * throws an IOException indicating what went wrong.
 */
synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException {
    synchronized (fdLock) {
        if (!closePending && (socket == null || !socket.isBound())) {
            NetHooks.beforeTcpConnect(fd, address, port);
        }
    }
    try {
        acquireFD();
        try {
		//根据操作系统不同，调用不同socketConnect的实现，比如win10调用的是DualStackPlainSocketImpl类的socketConnect方法
            socketConnect(address, port, timeout);
            /* socket may have been closed during poll/select */
            synchronized (fdLock) {
                if (closePending) {
                    throw new SocketException ("Socket closed");
                }
            }
            // If we have a ref. to the Socket, then sets the flags
            // created, bound & connected to true.
            // This is normally done in Socket.connect() but some
            // subclasses of Socket may call impl.connect() directly!
            if (socket != null) {
                socket.setBound();
                socket.setConnected();
            }
        } finally {
            releaseFD();
        }
    } catch (IOException e) {
        close();
        throw e;
    }
}
//DualStackPlainSocketImpl类的socketConnect方法
void socketConnect(InetAddress address, int port, int timeout) throws IOException {
    int nativefd = checkAndReturnNativeFD();

    if (address == null)
        throw new NullPointerException("inet address argument is null.");

    int connectResult;
    if (timeout <= 0) {
		//如果未设置超时时间(即超时时间为0)或超时时间小于0，阻塞直到连接建立完成或抛出异常
        connectResult = connect0(nativefd, address, port);
    } else {
		//阻塞直到连接建立完成或抛出异常，阻塞时间最大值为设置的timeout，超过则抛出异常
        configureBlocking(nativefd, false);
        try {
            connectResult = connect0(nativefd, address, port);
            if (connectResult == WOULDBLOCK) {
                waitForConnect(nativefd, timeout);
            }
        } finally {
            configureBlocking(nativefd, true);
        }
    }
    /*连接建立之后根据nativefd设置本地端口
     * We need to set the local port field. If bind was called
     * previous to the connect (by the client) then localport field
     * will already be set.
     */
    if (localport == 0)
        localport = localPort0(nativefd);
}
```  
#### **Socket Read操作**
Socket read操作与文件读取操作本质上是相同的，只不过数据来源不同，Socket read数据来源是连接对方通过网络发来的数据，文件读取操作数据来源是磁盘上的数据，两种read操作都是阻塞的，并且阻塞都分为两个阶段，一是等待数据在内核空间中被准备好，二是将数据从内核空间拷贝到用户空间。Socket read操作直接操作的数据结构是内核空间中的TCP数据接收队列，比如我们当前想一次性读取50个字节，若TCP接收数据队列中有可读的数据，则read操作返回值为当前缓冲区中可一次性读取的字节数(最大为50，可能小于50)，若没有可读的数据，则read操作会阻塞直到有数据准备好。  

若客户端设置了SoTimeout选项，比如设置为阻塞5s即超时，超时后对于客户端会抛出异常 java.net.SocketTimeoutException: Read timed out，SocketTimeoutException属于checkedException，若客户端catch此Exception，客户端与服务器建立的socket连接还可以进行正常读写，否则客户端程序停止执行，socket连接被关闭，服务器端基于此socket进行的读操作当内核接收缓冲区数据为空时会直接返回-1。**问题：socket连接关闭后，服务器端基于此socket进行的写操作会产生什么问题呢？**  

对于TCP接收数据缓冲区，我们可以通过setReceiveBufferSize(int size) 来设置其大小，在默认情况下，输入流的接收缓冲区是65536个字节（64K）。这个值是Java所建议的输入缓冲区的大小。但最好不要将输入缓冲区设得太小，否则会导致传输数据过于频繁，从而降低网络传输的效率。  

对于文件读写操作，读到文件尾时read会返回-1，那么对于基于socket的read操作，什么时候会返回-1呢？答案是当一方关闭了输出时(比如调用shutdownOutput方法或者出现异常关闭整个socket)，另一方在接收缓冲区数据为空的条件下进行读取就会返回-1。具体可参见：[TCP Socket通信中由read返回值造成的的死鎖問題](https://hk.saowen.com/a/bac70627c32a66f096221ffd83eb586735dbe57ea94163a538d54ef2264c7603)     

通过java.net.socket进行read操作源码分析如下：
```java
public class Socket implements java.io.Closeable {
	public InputStream getInputStream() throws IOException {
        if (isClosed())
            throw new SocketException("Socket is closed");
        if (!isConnected())
            throw new SocketException("Socket is not connected");
        if (isInputShutdown())
            throw new SocketException("Socket input is shutdown");
        final Socket s = this;
        InputStream is = null;
        try {
            is = AccessController.doPrivileged(
                new PrivilegedExceptionAction<InputStream>() {
                    public InputStream run() throws IOException {
						//实际调用的是AbstractPlainSocketImpl类的getInputStream()方法
                        return impl.getInputStream();
                    }
                });
        } catch (java.security.PrivilegedActionException e) {
            throw (IOException) e.getException();
        }
        return is;
    }
}
abstract class AbstractPlainSocketImpl extends SocketImpl {
	protected synchronized InputStream getInputStream() throws IOException {
        synchronized (fdLock) {
            if (isClosedOrPending())
                throw new IOException("Socket Closed");
            if (shut_rd)
                throw new IOException("Socket input is shutdown");
            if (socketInputStream == null)
				//真正的InputStream实现类是SocketInputStream
                socketInputStream = new SocketInputStream(this);
        }
        return socketInputStream;
    }
}
class SocketInputStream extends FileInputStream {
	public int read() throws IOException {
        if (eof) {
            return -1;
        }
        temp = new byte[1];
        int n = read(temp, 0, 1);
        if (n <= 0) {
            return -1;
        }
        return temp[0] & 0xff;
    }
	public int read(byte b[]) throws IOException {
        return read(b, 0, b.length);
    }
	public int read(byte b[], int off, int length) throws IOException {
        return read(b, off, length, impl.getTimeout());
    }
	//实际的read方法实现
	int read(byte b[], int off, int length, int timeout) throws IOException {
        int n;

        // EOF already encountered
        if (eof) { return -1; }

        // connection reset
        if (impl.isConnectionReset()) { throw new SocketException("Connection reset"); }

        // bounds check
        if (length <= 0 || off < 0 || off + length > b.length) {
            if (length == 0) {
                return 0;
            }
            throw new ArrayIndexOutOfBoundsException();
        }

        boolean gotReset = false;

        // acquire file descriptor and do the read
        FileDescriptor fd = impl.acquireFD();
        try {
			//调用socketRead方法进行读取，指定超时时间
            n = socketRead(fd, b, off, length, timeout);
            if (n > 0) {
                return n;
            }
        } catch (ConnectionResetException rstExc) {
            gotReset = true;
        } finally {
            impl.releaseFD();
        }

        /*
         * We receive a "connection reset" but there may be bytes still
         * buffered on the socket
         */
        if (gotReset) {
            impl.setConnectionResetPending();
            impl.acquireFD();
            try {
                n = socketRead(fd, b, off, length, timeout);
                if (n > 0) {
                    return n;
                }
            } catch (ConnectionResetException rstExc) {
            } finally {
                impl.releaseFD();
            }
        }

        /*
         * If we get here we are at EOF, the socket has been closed,
         * or the connection has been reset.
         */
        if (impl.isClosedOrPending()) {
            throw new SocketException("Socket closed");
        }
        if (impl.isConnectionResetPending()) {
            impl.setConnectionReset();
        }
        if (impl.isConnectionReset()) {
            throw new SocketException("Connection reset");
        }
        eof = true;
        return -1;
    }
	private int socketRead(FileDescriptor fd,
                           byte b[], int off, int len,
                           int timeout)
        throws IOException {
		//调用native方法socketRead0进行读取
        return socketRead0(fd, b, off, len, timeout);
    }
	private native int socketRead0
		(FileDescriptor fd, byte b[], int off, int len, int timeout) throws IOException;
}
```
调用通过socket获取的InputStream的read操作后关闭的实际是整个socket，也就是说名义上关闭的是读取操作，实际上关闭后对于此socket的写操作也无法进行了。  
```java
class SocketInputStream extends FileInputStream {
	public void close() throws IOException {
        // Prevent recursion. See BugId 4484411
        if (closing)
            return;
        closing = true;
        if (socket != null) {
            if (!socket.isClosed())
				//实际关闭的是整个socket
                socket.close();
        } else
            impl.close();
        closing = false;
    }
}
```
#### **Socket Write操作**
Write操作直接操作的是底层TCP输出数据缓冲区，每次Write操作都会将指定要写出的数据全部写出之后才返回，如果TCP输出数据缓冲区大小不足以容纳当前要写出的字节数，write操作将会阻塞直到缓冲区中有足够空间，并且write操作不能像read操作一样指定阻塞超时时间，如果缓冲区中一直没有足够空间，write操作会一直阻塞下去。一个Write操作阻塞的示例如下：
```java
public class Client {
    private static final String SERVERIP = "127.0.0.1";
    private static final int PORT = 8098;

    public static void main(String[] args) throws IOException, InterruptedException {
        try(Socket socket = new Socket()) {
            SocketAddress socketAddress = new InetSocketAddress(SERVERIP, PORT);//连接远程8098端口
            socket.setSendBufferSize(8 * 1024);//设置客户端发送缓冲区大小为8k
            socket.connect(socketAddress, 50000);//设置连接超时时间为50000ms         
            byte[] buffer = new byte[1024];
            Arrays.fill(buffer, (byte) 1);
            OutputStream os = socket.getOutputStream();
            for (int i = 0; i < 1024; i++) {
                os.write(buffer);      
                System.out.println("第" + i + "次写出" + " buffer size: " + socket.getSendBufferSize());
            }
        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
public class Server {
    private static final int PORT = 8098;

    public static void main(String[] args) {
        try(ServerSocket serverSocket = new ServerSocket(PORT)) {
            while (true) {           
                serverSocket.setReceiveBufferSize(8 * 1024);//设置接收数据缓冲区大小为8k
                Socket client = serverSocket.accept();
                new Thread(new Runnable() {
                    @Override
                    public void run() {                       
                        while (true) {
                            try {
                                Thread.sleep(1000);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }).start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

执行结果为：
	第0次写出 buffer size: 8192
	第1次写出 buffer size: 8192
	...
	第23次写出 buffer size: 8192
```
由执行结果可以看出由于服务端一直没有读取数据，客户端write操作在第24次写出之后就阻塞了，**问题：客户端发送缓冲区大小为8K，服务端接收缓冲区大小也为8K，理论来讲客户端发送16K数据之后不是就应该阻塞？为何可以发送24K数据？**

什么情况下会造成TCP输出数据缓冲区不足以容纳当前要写入的数据呢？

我们知道TCP滑动窗口大小是由网络拥塞状况与客户端接收窗口大小共同决定的，假定网络环境通畅，一种极端情况就是接收端对于接收到的数据一直不进行read操作导致接收端输入数据缓冲区满，接收端滑动窗口大小变为0，发送端无法再通过网络将发送端发送缓冲区的数据发送出去，造成发送端发送缓冲区满，write操作阻塞。可以通过SendBufferSize方法设置TCP输出数据缓冲区大小。  

由此也可理解为何对于socket来讲发送数据时的flush操作没有作用，这是因为数据能否发出不是由自己决定而是由对方或者网络状况决定的。通过分析SocketOutputStream源码可见其实际调用的是OutputStream类的flush方法，并没有进行任何操作。    

socket通过SocketOutputStream类进行实际write操作，SocketOutputStream相关源码如下：  
```java
class SocketOutputStream extends FileOutputStream {
    public void write(int b) throws IOException {
        temp[0] = (byte)b;
        socketWrite(temp, 0, 1);
    }

    public void write(byte b[]) throws IOException {
        socketWrite(b, 0, b.length);
    }

    public void write(byte b[], int off, int len) throws IOException {
        socketWrite(b, off, len);
    }

	private void socketWrite(byte b[], int off, int len) throws IOException {

        if (len <= 0 || off < 0 || off + len > b.length) {
            if (len == 0) {
                return;
            }
            throw new ArrayIndexOutOfBoundsException();
        }

        FileDescriptor fd = impl.acquireFD();
        try {
            socketWrite0(fd, b, off, len);
        } catch (SocketException se) {
            if (se instanceof sun.net.ConnectionResetException) {
                impl.setConnectionResetPending();
                se = new SocketException("Connection reset");
            }
            if (impl.isClosedOrPending()) {
                throw new SocketException("Socket closed");
            } else {
                throw se;
            }
        } finally {
            impl.releaseFD();
        }
    }
	
	//实际调用native write操作
	private native void socketWrite0(FileDescriptor fd, byte[] b, int off,
                                     int len) throws IOException;
	
	//对于输出流的关闭操作实际上是关闭的整个socket
	public void close() throws IOException {
        // Prevent recursion. See BugId 4484411
        if (closing)
            return;
        closing = true;
        if (socket != null) {
            if (!socket.isClosed())
                socket.close();
        } else
            impl.close();
        closing = false;
    }
}
```
#### **Socket Close操作**
* socket.shutdownInput():假设A与B建立了Socket连接，在A端调用此方法，A端接收缓冲区剩余的数据被读取之后再进行read操作会返回-1;对于B端能否感知到A端输入已经关闭？可以感知到，B端在A端关闭输入后向A端发送数据是在B端会抛出异常，对于A端在关闭输入之后会将接收到的数据静静的丢弃。  
* socket.shutdownOutput():假设A与B建立了Socket连接，在A端调用此方法，A端发送缓冲区剩余的数据会依次发送给B端，之后在A端再向B写数据会抛出IOException。对于B端，将输入缓冲区数据读完之后read操作会返回-1。  
* socket.getInputStream().close():关闭整个socket。  
* socket.getOutStream().close():关闭整个socket。  
* socket.close():关闭整个socket。  

Socket关闭时发送缓冲区与接收缓冲区中均有可能存在数据，socket关闭后，接收缓冲区中存在的数据不能再被读取(否则会抛出异常java.net.SocketException: socket closed)，发送缓冲区中的数据也会被丢弃。可以通过设置setSoLinger(boolean on, int linger)方法阻塞close方法一段时间，在关闭之前尽可能多的将发送缓冲区中剩余数据送出。  

#### **Socket相关选项设置及其作用**
* setTcpNoDelay(boolean on)：设置TCP_NODELAY选项,true则禁用Nagle算法，false则启用Nagel算法，默认为false。有时通过禁用Nagle算法可以解决小包数据的延迟发送问题，具体可参见：[神秘的40毫秒延迟与TCP_NODELAY](http://jerrypeng.me/2013/08/mythical-40ms-delay-and-tcp-nodelay/)     
* setSoTimeout(int timeout)：设置read操作超时时间，以ms为单位，若不设置则默认阻塞直到接收缓冲区中有数据准备好。
* setReceiveBufferSize(int size)：设置TCP输入流的接收缓冲区大小，默认是65536个字节（64K），仅仅是给操作系统一个建议，实际的接收缓冲区大小还需通过getReceiveBufferSize获得。对于接收缓冲区，当大小小于64k时是可以在任意时刻动态更改的，**当大于64k时，需要分两种情况进行处理：**一、对于服务端，必须在通过serverSocket.accept()方法创建socket之前通过ServerSocket.setReceiveBufferSize(int)设置要创建的socket的接收缓冲区大小；二、对于客户端必须在连接到服务器之前设置接收缓冲区大小。  
* setSendBufferSize(int size)：设置TCP输出流的发送缓冲区大小，默认是65536个字节（64K），仅仅是给操作系统一个建议，实际的发送缓冲区大小还需通过setSendBufferSize获得。  
* setSoLinger(boolean on, int linger)：若调用socket.close方法时发送缓冲区中还存在尚未发出的数据，则阻塞linger时间之后close方法才返回。当on为true时linger选项才有效，linger为0代表close方法立即返回。linger单位为秒，若close时发送缓冲区中并没有数据，则close方法可立即返回，不必等到linger时间。  
* sendUrgentData(int data)：发送一字节的UrgentData，即int data中的低八位。此urgentdata将被另一方接收的顺序是在之前已经通过SocketOutputstream发出的数据之后，在之后要通过SocketOutputstream发出的数据之前。**注意：这里所指的urgentdata与TCP协议中规定的urg标志置位的数据报接收要求有所不同，TCP协议中规定当接收端的TCP接收到URG位置1的段，它就利用紧急指针的值从段中提取出紧急数据，并不按序的将其传递给接收应用程序。但java中通过sendUrgentData发送的数据在接收方缓冲区中有数据时会按照顺序被接收方接收，并不会被优先接收。**  
* setOOBInline(boolean on)：与sendUrgentData方法对应，只有在接收方setOOBInline设置为true时，发送方发送的urgentdata数据才能被接收方接收，否则接收方会将接收到的urgentdata静静丢弃。**问题：使用sendUrgentData()方法检测连接是否断开是否合理？？** 即
```java
try{
      socket.sendUrgentData(0xFF);
}catch(Exception ex){
      reconnect();
}
``` 
* setKeepAlive(boolean on):

 
&emsp;&emsp;而对于TCP当内核中的TCP发送缓冲区中没有足够空间时，会阻塞当前write操作，直到腾出空间完成write操作后才返回。  
&emsp;&emsp;问题：如何在程序中设置TCP发送缓冲区与接收缓冲区大小？  

&emsp;&emsp;**问题：对于编程中涉及到的所有阻塞过程，了解为什么会阻塞，什么情况下可从阻塞返回，可否通过参数调整来消除阻塞？？** 

&emsp;&emsp;**呼入连接请求队列：**
&emsp;&emsp;每个TCP连接的建立过程都是由操作系统内核中的TCP模块帮我们维护的，os会将三次握手后的TCP连接放入呼入连接请求队列中，我们在程序中通过serverSocket.accept()可以直接获得建立好的连接。应用层接收连接后此连接就会从呼入连接请求队列中取出。当应用层由于操作系统忙或者其他原因迟迟不对呼入连接请求队列中三次握手后的连接进行处理的话，就可能导致呼入连接请求队列满，造成的后果就是对于客户端发出的SYN建立TCP连接请求不会做出任何响应，之后客户端就会重发SYN连接数据包直到达到最大重传次数后向客户端返回TCP连接建立失败的错误。当一个TCP连接请求被加入到服务端连接请求队列之后，客户端就认为服务器进程已经准备好接收数据了，之后客户端向服务器发送数据，如果此时服务端并没有对连接请求队列中的这个请求进行处理，服务器的TCP仅将接收的数据放入缓冲队列。     

&emsp;&emsp;**问题：**Java网络编程时如何在应用层设置呼入连接请求队列的大小？呼入连接请求队列对系统所允许的最大连接数或者并发服务器所能处理的并发客户数并无影响？  
&emsp;&emsp;答：系统所允许的最大连接数主要取决于系统所能支持的最大线程或进程数，与呼入连接请求队列的大小无关。  

&emsp;&emsp;OSI模型运输层的实现是将连接请求的到达与接受分开，应用程序可以选择是否接收一个连接；但TCP/IP模型不是这样，当请求到达应用层时，TCP三次握手已经完成，连接已经建立起来了！如果此时应用程序不想为此客户端服务，服务器所能做的就是关闭连接(发送FIN)，或者复位连接(发送RST)。  

&emsp;&emsp;**问题：**OSI七层模型与TCP/IP四层模型在具体实现上有何差异？？？    
&emsp;&emsp;目前网络中TCP/IP协议族成为占统治地位的业务体系结构，而OSI模型却从未实现过。

