## JVM 学习笔记

### 内存模型  
1、	Java内存模型与Java运行时数据区对比
Java内存模型：java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java并发程序在各种平台下都能达到一致的内存访问效果。(在此之前，主流程序语言比如c、c++直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另一套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。)
Java内存模型中有一系列的规定(比如原子性可见性有序性等的规定)，致力于解决上述的并发程序不同平台上不兼容的问题，这个规定是由JVM来实现的，不同平台下的JVM有不同的实现方式，但在上层Java开发人员的眼中，他们都是一致的，因为他们都符合Java内存模型的规定。 
Java运行时数据区：Java虚拟机规定JVM在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在(比如堆区)，有的依赖用户线程的启动和销毁而建立和销毁(比如虚拟机栈)。
Java虚拟机帮助运行在其上的Java进程完成内存管理操作，可以理解为Java虚拟机在启动时向os 通过malloc操作申请了一大块内存，之后运行在其上的java进程使用的内存就由jvm来管理，当jvm发现可用的内存不够的时候，就进行垃圾收集操作，如果还不够，就再向os申请内存。
通过Java运行时数据区完成的内存管理操作是符合Java内存模型的。
JAVA内存模型中涉及到的主内存和工作内存等概念与Java运行时数据区中的Java堆、栈、方法区等并不是同一个层次上的内存划分，这两者基本上是没有关系的，JMM是为了解决防止同一套并发程序不同平台上运行不兼容的问题(比如在编译时插入一些屏障指令防止os或硬件优化对指令重排序)；Java运行时数据区规定了各个厂家实现JVM时的进行内存管理的一套规范，各个厂家在实现这个规范的时候给出的最后JVM产品一定是满足JVM内存模型的。
JMM重点解决的问题是主内存与工作内存的交互的问题(不管主内存与工作内存在JVM中怎么实现)，Java运行时数据区重点解决的问题是主内存与工作内存在JVM中具体怎么实现的问题；JVM实现时通过JAVA编译器(比如在编译时插入一些屏障指令防止os或硬件优化对指令重排序)与Java运行时数据区的配合才可以满足JMM中的规定。

JMM中的主内存与工作内存如果一定要对应到Java运行时数据区中的话，可以认为主内存对应于Java堆中的对象实例数据部分(Java堆中对象除了对象实例数据，还包含对象的MarkWord、对象类型数据指针以及用于字节对其的数据填充)，而工作内存对应于虚拟机栈中的部分区域。

### GC相关
**Minor GC触发条件：**当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。  
  
**Major GC触发条件（只有CMS存在Major/old gc的概念，其余老年代收集器Major GC = Full GC）：**(1)GC收集器根据条件判断的(是不是只有CMS有这种条件判断？？？对于其他老年代收集器器只有条件1)：以CMS GC为例，它主要是定时去检查old gen的使用量，当使用量超过了触发比例就会启动一次CMS GC，对old gen做并发收集。  
    
**Full GC触发条件：**(1)当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC (2)如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC； (3)System.gc()、heap dump带GC，默认也是触发full GC。 (4)即使之前young GC的平均晋升大小<=目前old gen剩余的空间，但old gen剩余的空间（剩余空间是否要求连续？？？）<(Eden.used+From.used)，也会触发Full GC  

Full GC本身不会先进行Minor GC，我们可以配置-XX:+ScavengeBeforeFullGC（非CMS回收算法）、CMSScavengeBeforeRemark（CMS回收算法）可以，让Full GC之前先进行一次Minor GC，因为老年代很多对象都会引用到新生代的对象，先进行一次Minor GC可以提高老年代GC的速度。   

**HotSpot VM只有CMS的concurrent collection可以做到只收集old gen,其余用于老年代的收集器在收集的时候都是收集整个堆，所以对于除了CMS收集器之外的其它老年代的收集器，MajorGC是等于FullGC的，因为都是收集整个堆。**  


[Full GC为什么那么慢？为什么老年代垃圾回收效率比新生代低很多？为什么Minor gc速度比Major GC慢？](https://blog.csdn.net/sinlff/article/details/70138651)  

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立。那么Minor GC可以确保是安全的，如果不成立，则需要进行一次Full GC。  

**老年代使用CMS算法，可能在老年代产生很多内存碎片，这样在新生代中分配一个大对象时，就可能出现往往老年代还有很大剩余空间，但无法找到足够大的连续空间来分配当前对象,不得不触发一次Full GC(ParNew GC + CMS GC + PermGC)。CMS的解决方案是使用UseCMSCompactAtFullCollection参数(默认开启)，在识别出是由于这种情况引起的Full GC时开启内存碎片整理。**    

**CMS并发GC不是“full GC”。CMS GC要决定是否在full GC时做压缩，会依赖几个条件。**其中， 
第一种条件，UseCMSCompactAtFullCollection 与 CMSFullGCsBeforeCompaction 是搭配使用的；前者目前默认就是true了，也就是关键在后者上。 
第二种条件是用户调用了System.gc()，而且DisableExplicitGC没有开启。 
第三种条件是young gen报告接下来如果做增量收集会失败；简单来说也就是young gen预计old gen没有足够空间来容纳下次young GC晋升的对象。 
上述三种条件的任意一种成立都会让CMS决定这次做full GC时要做压缩。 

CMSFullGCsBeforeCompaction 说的是，在上一次CMS并发GC执行过后，到底还要再执行多少次full GC才会做压缩。默认是0，也就是在默认配置下每次CMS GC顶不住了而要转入full GC的时候都会做压缩。 把CMSFullGCsBeforeCompaction配置为10，就会让上面说的第一个条件变成每隔10次真正的full GC才做一次压缩（而不是每10次CMS并发GC就做一次压缩，目前VM里没有这样的参数）。这会使full GC更少做压缩，也就更容易使CMS的old gen受碎片化问题的困扰。 本来这个参数就是用来配置降低full GC压缩的频率，以期减少某些full GC的暂停时间。CMS回退到full GC时用的算法是mark-sweep-compact，但compaction是可选的，不做的话碎片化会严重些但这次full GC的暂停时间会短些；这是个取舍。  

参考[JVM调优——之CMS 常见参数解析](https://www.cnblogs.com/onmyway20xx/p/6605324.html)
  
**问题：**新生代总空间900M，含有两个250M的大对象，老年代900M，也含有两个250M的大对象；现在要新创建一个占用空间为500M的大对象，新生代容纳不下，进行minor gc之前发现老年代最大可用的连续空间小于新生代所有对象总空间，所以需要改为进行full gc，假设full gc之后这4个250M大对象都没有被回收，那么此500M的大对象是否可以被分配？如果可以的话，是不是由于把新生代的一个250M的大对象在Full GC的时候搬运到了老年代，导致新生代有一个250M的大对象，老年代有3个250M的大对象，之后新来的这个对象在新生代分配，新生代占用了500+250=750M，老年代也占用了250*3=750M？？？  


**为什么要求老年代的空间大于新生代的空间呢？(老年代与新生代的空间比例至少是1：1)**   
因为新生代进行minor GC的时候需要空间分配担保，如果老年代空间小于新生代空间，就可能出现频繁Full GC，这是不能接受的。因为新生代一般等到所剩的空间无法给新来的对象再分配的时候才会进行minor GC，如果老年代空间小于新生代空间，比如老年代为500M，新生代为1G，那么就可能出现新生代空间为900M，需要新分配一个200M的空间给新来的对象，检测到空间不足了，准备进行minor GC，但是检测到老年代可用内存空间不足以容纳新生代所有对象，于是改为进行full GC，这就不行了，本来一次minor gc就可以解决的问题，变成了一次full gc！！！    

所以在jvm中进行配置的时候要求newRatio至少为1。    

**将长期存活的大对象放在堆外可以减少Full GC，why？？？**  
可能是由于长期存活的大对象如果在老年代的话，可能会经常引起minor gc时的内存分配担保失败，这样就会经常造成由minor gc到full gc的转化，将其放在堆外可以减少fullgc次数，并且可以减少full gc 时stw的时间(不需要扫描这块大对象对应的内存)。    

优秀文章：[精品-从实际案例聊聊Java应用的GC优化](https://www.mtyun.com/library/jvm_optimize)  

#### 内存分配担保机制
新生代默认有一块Eden区域，两块Survivor区域；新生代的收集过程是先标记eden+一块survivor中的区域的存活的对象，标记之后将其复制到另外一块survivor区域中，之后将eden和那一块survivor中的所有空间直接清除，这样效率比较高；由于新生代的对象中98%都是朝生夕灭的，所以标记之后存活的对象往往很少，survivor区域并不需要设置的很大，eden区域与两个survivor区域的比值的默认设置是8:1:1，大部分情况下来说survivor区域都足以容纳minor gc标记后存活的对象了。但是假设这种极端的情况。标记之后发现eden与其中一块survivor区域所有的对象都仍然存活，那怎么办呢？**这个时候就需要老年代进行内存分配担保，保证老年代剩余的空间+一块survivor的空间可以容纳新生代中的标记之后的存活的对象。**如果内存分配担保成功，这时可以进行一次minor gc，否则就要改为进行一次full gc。  

**问题：**新生代中要分配一个大对象，所剩空间不足，minor gc标记之后发现老年代空间不足以进行内存分配担保，转为进行full gc，full gc的时候如果老年代能把新生代的一部分对象转移过来，新生代是可以容纳这个大对象的；但是如果在fullgc的时候新生代剩余的所有的存活的对象都不符合进入老年代的标准，那么jvm会从新生代转移一部分不符合的条件的对象到老年代以分配空间给新来的大对象吗？？？如果jvm不这么做，就会出现明明 新生代+老年代剩余总空间 > 要分配的大对象所需要的空间，却出现分配失败的情况。   

**问题：**一个对象所占用的空间或者全部在新生代，或者全部在老年代吗？  比如一个占用很大内存的一维数组是不是只能全部在新生代或者全部在老年代？？？  如果将这个一维数组分割为多个小数组保存在一个二维数组对象中，这个二维数组所占用的空间有没有可能一部分在新生代一部分在老年代？？？  将一维数组分割为多个二维数组的目的在于将一个大对象分割为多个小对象。  

**新生代与老年代的比值设置为多大比较好呢？？？**  
新生代越大，就更容易出现内存分配担保机制失败，频繁出现Full GC；新生代越小，就可能导致新生代的对象提前被加载到老年代，这样老年代里的短命对象就会很多，也容易出现Full GC。所以这个比值需要好好考虑。   

**那对象什么时候会被移动到老生代呢？有以下条件：**   
1. Survivor区域中存活对象占用Survivor空间达到了指定的阈值。   
2. 对象在Survivor空间每倒腾一次其年龄就加1，如果一个对象的年龄达到了一个阈值，也会被移动到老生代。   
3. 大对象会在创建的时候就会被直接放到老生代。  

#### 枚举根节点
在java中，有四种对象可以作为“GC Roots”：
1. 栈帧（第一章的名词）中的引用对象。（栈中的）
2. 静态属性引用的对象。（方法区中的）
3. 常量引用的对象。（方法区中的）
4. 本地方法栈中JNI引用的对象。（本地方法栈中的）

**如何快速且准确地完成GC Roots枚举及沿着GC引用链进行快速查找？？？**
从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用(例如常量或静态类属性)与执行上下文(例如栈帧中的本地变量表)中，现在很多应用仅仅方法区就有数百MB，如果要逐个检查这里面的引用，那么必然会消耗很多时间，怎么办？？？

OopMap结构可以用来解决这个问题，虚拟机使用这个数据结构可以直接得知哪些地方存放着对象引用，这样，GC在扫描时就可以直接得知这些信息了。  

**问题：**对于扫描虚拟机栈与本地方法栈的引用加入OopMap，我的理解仍然是需要扫描整个虚拟机栈和本地方法栈，这个是避免不了的，而对于方法区，由于在类加载时就将对应的对象引用所在位置就加入了OopMap中，所以并不需要遍历方法区。对吗？？？      

**对于OopMap结构，我觉得可以分为两种：一、外部记录GC Roots引用的OopMap，通过这个OopMap可以快速枚举到所有的GC Roots对象；二、对象的类型信息里有记录自己的OopMap，这个是由HotSpot在类加载完成的时候将对象内什么偏移量上是什么类型的数据计算出来后放在对象内部的OopMap中的。**  

对于上述**类型一中外部记录GC Roots引用的OopMap，GC Roots引用来源主要有两个，一是方法区中的常量引用的对象(static final)以及方法区中的静态属性引用的对象(static),这个比较好记录，在类加载时就可以将这个对象引用在方法区中存放的位置，二是虚拟机栈和本地方法栈中的涉及到的GC ROOTs**，这个就比较难办了，因为栈中的引用关系是不断在变化的，在时刻1中可能有A，B两个对象，之后将A置为null，新创建一个对象C，时刻2可能就有B、C两个对象，像这样导致栈中引用关系不断变化的指令是非常多的，如果想要在任意时刻都可以进入GC，那么就要为每个时刻都维护一个不同的OopMap，这样就会占用很多的额外空间；如果想要节省空间，那么就要复用之前时刻的OopMap，这样时间开销肯定会增大；所以想要在任意时刻都可以进入GC是不现实的，为了解决在外部OopMap中记录栈中GC Roots引用的问题，就出现了**安全点的概念**。  

HotSpot并不是在每条指令执行时，每个时刻都更新OopMap，而仅是在所谓的安全点时才去更新OopMap。对于安全点的选择，既不能太少以至于让进入GC前的准备时间太长，也不能太多以至于过分增大运行时的负荷。    

安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间运行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具备这些功能的指令才会产生SafePoint。  

再总结一下，安全点的位置主要在：  
* 循环的末尾
* 方法临返回前/调用方法的call指令后
* 可能抛异常的位置

为什么要以“是否具有让程序长时间执行的特征”作为安全点的选定标准呢？我的理解是程序在同一块代码执行时间越长越可能发生GC，这样安全点位置以上述标准进行选定后就可以尽可能的缩短与发生GC的位置之间的距离，之后就可以尽快的运行到安全点所在位置进行GC，缩短准备时间。   

**对于OopMap的另外一个更重要的作用是可以帮助HotSpot实现准确式GC**，关于准确式GC，参考：[找出栈上的指针/引用](http://rednaxelafx.iteye.com/blog/1044951)   

对于安全点，另一个需要考虑的问题是如何在GC发生时让所有线程都跑到最近的安全点上再停顿下来。现在的虚拟机实现基本上都是采用主动式中断的方式，即当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程去主动轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方(因为既然已经发生GC了，那么就证明内存吃紧，不应该再尝试分配新的内存了，所以在分配内存的地方加上中断标志以进入GC。)  

**问题：**这里讲的是进入安全点时需要中断所有线程，是STW吗？CMS的实现是否与上述理论有出入？？？  

#### GC收集器
这里讨论的收集器基于JDK1.7Update 14之后的HotSpot虚拟机，这个虚拟机包含的所有收集器如下图所示：

<img src="/img/2018-12-5/sevenTypeGC.png" width="700" height="700" alt="7种常用垃圾收集器" />
<center>图1：7种常用垃圾收集器</center>

上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。

**Serial收集器：**  
是一个单线程的收集器，这里所说的单线程有两个意义：一是它只会使用一个CPU或一条收集线程去完成垃圾收集工作；二是它在进行垃圾收集时必须暂停其它所有的工作线程。简单而高效，是运行在Client模式下的虚拟机的一个很好的选择。   

**ParNew收集器：**是Serial收集器的多线程版本，除了使用多条线程进行收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法(使用停止-复制算法进行收集)、Stop The World(注意Minor GC时也是要Stop The World的！！！)、对象分配规则、回收策略等都与Serial收集器完全一样。是Server模式下的虚拟机中首选的新生代收集器，是除了Serial收集器之外唯一可以与CMS收集器配合工作的收集器。  

**Parallel收集器：**它的目标是达到一个可控制的吞吐量(CPU运行于用户代码时间 / (运行用户代码时间+垃圾收集时间))，每次GC停顿时间可能较长，但花费总时间较少。  

**Serial Old收集器：**是Serial收集器的老年代版本，单线程收集，使用标记-整理算法。  

**Parallel Old收集器：**是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。  

**CMS：以获取最短回收停顿时间为目标的收集器，使用标记-清除算法进行收集。**  
1. 初始标记阶段Init-mark：该阶段进行可达性分析，这是CMS中两次stop-the-world事件中的一次。它有两个目标：一是标记老年代中所有的GC Roots；二是标记被年轻代中活着的对象引用的对象。由于它仅仅标记GC ROOT能直接关联到的对象，所以很快。这个阶段对于老年代与新生代都会访问，顺着GC ROOts开始访问，找到GCRoots可以访问到的老年代中的第一个对象。    
2. 开始并发标记(concurrent-mark) 阶段：在第一个阶段被暂停的线程重新开始运行，由前阶段标记过的老年代中的GCRoots对象出发，所有可到达的对象都在本阶段中标记。这个阶段会遍历整个老年代，不涉及到对新生代对象的访问。    
3. Concurrent Preclean：由于concurrent-mark阶段通常时间较长，在其执行过程中会有很多从新生代新晋升到老年代的对象或者新创建或被更新的对象，通过并发的重新扫描这些对象，预清理阶段可以减少下一个STW重新标记阶段的工作量。简而言之：这个阶段负责前一个阶段标记了又发生改变的对象标记；我觉得这个阶段新生代和老年代都会被扫描到。      
4. Concurrent Abortable Preclean：这个阶段尝试着去承担STW的Final Remark阶段足够多的工作。   
5. Final Remark：这个阶段是CMS中第二个并且是最后一个STW的阶段。该阶段的任务是完成标记整个年老代的所有的存活对象。由于之前的预处理是并发的，它可能跟不上应用程序改变的速度，这个时候，STW是非常需要的来完成这个严酷考验的阶段。  

**为什么CMS收集器使用标记-清除算法而不是标记-整理算法呢？**
因为CMS是以最短回收停顿时间为目标的收集器，内存碎片的合并整理过程是无法并发的，空间碎片问题没有了，势必会带来新的停顿时间变长的问题。所以CMS收集器提供了一个+UseCMSCompactAtFullCollection开关参数(默认就是开启的)，用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程。+UseCMSCompactAtFullCollection参数默认设置为0，表示每次进入Full GC时都进行碎片整理。  


为什么CMS进行过程中需要两次标记？？？  


**问题：**
1. 发生FullGC的时候新生代还是使用ParNew收集器，老年代使用CMS收集器吗？？？Minor GC时需要STW吗？**ParNew与CMS配合工作是在哪里体现的呢？？？**    
2. 在分代收集的垃圾收集器中，新生代一般比老年代小许多，新生代的收集也比老年代要频繁许多，回收新生代的对象时如果同时不得不扫描老年代的话，Minor GC的效率会下降不少，所以有了Dirty Card的存在用途吗？？？ Remembered Set避免全堆扫描？？？   
3. 为什么CMS不使用标记-整理算法而使用标记清除算法呢？内存碎片问题如何处理？？？https://blogs.oracle.com/jonthecollector/entry/when_the_sum_of_the  
4. Remark阶段存在的目的是因为并发标记阶段是和用户线程并发执行的过程，在并发标记的过程中应用程序可能会被已经标记过的对象进行修改，所以在Remark阶段需要STW，进行重新标记。在并发标记过程中应用程序对已经标记过的对象做的修改可能包含以下几种情况：
* 在并发标记的过程中有新的对象被创建，这部分新产生的对象属于下面问题中的浮动垃圾吗？  
* 原来标记的可以到达的对象现在到达不了了
* 原来标记的不能到达的对象现在又可以到达了(为什么会出现这种情况？？？是因为finalized吗？？？)      
5. CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在不断运行，所以肯定会有新的垃圾产生，**这一部分垃圾出现在标记过程之后(这里的标记过程指的是上面说的Initial mark吗？？？)，CMS无法在当次垃圾收集中处理掉他们，只好留待下一次GC时再清理掉。**要是CMS在运行过程中预留的内存无法满足程序需要，就会出现“Concurrent Mode Failure”，这时虚拟机就会启动后后备预案，临时启用Serial Old进行老年代的垃圾收集，不过这时STW时间就很长了。  

[为什么CMS两次标记时要 stop the world（阿里面试）](https://blog.csdn.net/fhy569039351/article/details/83960709)
[关于CMS、G1垃圾回收器的重新标记、最终标记疑惑?](https://www.zhihu.com/question/37028283/answer/78008095)  

[精品文章-不可错过的CMS学习笔记](https://www.jianshu.com/p/78017c8b8e0f)  

#### Minor GC与Full/Major GC日志分析
**问题：**如何根据GC日志计算GC实际耗时呢？   

Major GC STW的两个阶段：Phase 1: Initial Mark：，Phase 5: Final Remark  
参考：[GC之详解CMS收集过程和日志分析](https://www.cnblogs.com/zhangxiaoguang/p/5792468.html);  
[Java GC 日志详解（一图读懂）](https://blog.csdn.net/wanglha/article/details/48713217)

推荐阅读的GC相关书籍：
《The Garbage Collection Handbook》(https://book.douban.com/subject/6809987/)



