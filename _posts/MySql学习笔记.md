## MySql学习笔记
### 并发控制
MySql在两个层面上做并发控制：服务器层和存储引擎层。  

相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；InnoDB存储引擎既支持行级锁（ row-level locking），也支持表级锁，但默认情况下是采用行级锁。

MyISAM不支持事务。    

MySql中两种非常重要的锁策略：表锁(服务器层和存储引擎层都可以实现)和行级锁(仅在存储引擎中实现了行级锁)  
* 表级锁： 开销小，加锁快；不会出现死锁(因为MyISAM会一次性获得SQL所需的全部锁)；锁定粒度大，发生锁冲突的概率最高,并发度最低。
* 行级锁： 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

考虑上述特点，表级锁使用与并发性不高，以查询为主，少量更新的应用，比如小型的web应用；而行级锁适用于高并发环境下，对事务完整性要求较高的系统，如在线事务处理系统。  

表锁定：比如lock table software Read, branch write;对software加read锁，对branch加write锁。  
通过unlock tables对表解锁。  对表加读锁：大家都可以读，谁都不能写(包括本人)；对表加写锁，我自己可以读写，其它人既不能读又不能写。  

### 存储引擎
在MySQL中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。比如某个表如果不需要事务外键等特性，且插入查询数据操作较多，就可以优先使用MYISAM存储引擎，其它的表可以使用默认的InnoDB存储引擎。具体参考[MySql四种存储引擎](https://my.oschina.net/bkc/blog/617783)

**MySql默认使用Innodb引擎。其优势在于：**
* 支持事务操作，支持其ACID特性
* 行级锁定和Oracle风格的一致性读取可提高多用户并发性和性能
* InnoDB表将您的数据排列在磁盘上，以优化基于主键的查询。 每个InnoDB表都有一个称为聚簇索引的主键索引，用于组织数据以最大限度地减少主键查找的I / O
* 为了保持数据完整性，InnoDB支持FOREIGN KEY约束。 使用外键，将检查插入，更新和删除，以确保它们不会导致不同表之间的不一致

**使用Innodb表的好处：**
* 如果您的服务器因硬件或软件问题而崩溃，无论当时数据库中发生了什么，您都无需在重新启动数据库后执行任何特殊操作。 InnoDB崩溃恢复会自动完成在崩溃之前提交的所有更改，并撤消正在进行但未提交的任何更改。 只需重新启动并继续您离开的地方。
* InnoDB存储引擎维护自己的缓冲池，在访问数据时将表和索引数据缓存在主存储器中。 经常使用的数据直接从内存中处理。 此缓存适用于许多类型的信息并加快处理速度。 在专用数据库服务器上，通常会将最多80％的物理内存分配给缓冲池。
* 外键提供的参照完整性支持
* 如果数据在磁盘或内存中损坏，校验和机制会在您使用之前提醒您数据已经出现的问题。
* 使用每个表的相应主键列设计数据库时，将自动优化涉及这些列的操作。 在WHERE子句，ORDER BY子句，GROUP BY子句和join操作中引用主键列非常快。
* 插入，更新和删除通过称为change buffering的自动机制进行优化(换句话说就是会根据查询需求自动优化buffering pool？？？)，并且InnoDB不仅允许对同一个表进行并发读写访问，还可以缓存已更改的数据以简化磁盘I / O.
* 性能优势不仅限于具有长时间运行查询的巨型表。 当从表中反复访问相同的行时，称为自适应哈希索引的功能会接管以使这些查找更快，就像它们来自哈希表一样。
* 您可以压缩表和关联的索引。
* 您可以创建和删除索引，而对性能和可用性的影响要小得多。
* Truncating a file-per-table tablespace is very fast, and can free up disk space for the operating system to reuse, rather than freeing up space within the system tablespace that only InnoDB can reuse.
* 对于具有DYNAMIC行格式的BLOB和长文本字段，表数据的存储布局更有效。
* 您可以通过查询INFORMATION_SCHEMA表来监视存储引擎的内部工作方式。
* 您可以通过查询Performance Schema表来监控存储引擎的性能详细信息。
* 您可以将InnoDB表与其他MySQL存储引擎中的表自由混合，甚至可以在同一语句中。 例如，您可以使用连接操作在单个查询中组合InnoDB和MEMORY表中的数据。
* InnoDB专为处理大量数据时的CPU效率和最高性能而设计。
* 即使在文件大小限制为2GB的操作系统上，InnoDB表也可以处理大量数据。

**使用Innodb表的最佳操作：**
* 使用最常查询的列作为每个表的主键，如果没有明显的主键，则指定自动增量值。
* 在经常要进行多表连接的列建立外键，会自动建立索引，可以提高查询速度
* 关闭自动提交。 每秒承诺数百次会限制性能（受存储设备写入速度的限制）。
* 通过将START TRANSACTION和COMMIT语句括起来，将相关DML操作集合分组到事务中。 虽然您不想过于频繁地提交，但您也不希望同时发出大量的INSERT，UPDATE或DELETE语句，这些语句在没有提交的情况下运行数小时。
* 不使用LOCK TABLES语句
* 启用innodb_file_per_table选项或使用通用表空间将表的数据和索引放入单独的文件中，而不是系统表空间(**通用表空间与系统表空间的异同在哪里呢？？？**)。默认情况下启用innodb_file_per_table选项。
* 评估您的数据和访问模式是否受益于InnoDB表或页面压缩功能。 您可以在不牺牲读/写功能的情况下压缩InnoDB表。
* 使用选项--sql_mode = NO_ENGINE_SUBSTITUTION运行服务器，以防止在CREATE TABLE的ENGINE =子句中指定引擎的问题时使用其他存储引擎创建表。

**Innodb的ACID：**
ACID模型的一致性方面主要涉及到内部InnoDB处理以保护数据免于崩溃。 相关的MySQL功能包括：
* InnoDB doublewrite buffer.
* InnoDB crash recovery.

MyISAM适用情况：读多写少。  


### 事务控制

#### 两段锁协议
多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行的执行这些事务时的结果相同，称这种调度策略为可串行化的调度。  

使用两段锁协议产生的是可串行化调度，所谓两段锁协议指的是所有事务必须分为两个阶段对数据项进行加锁和解锁：
* 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁
* 在释放一个封锁之后，事务不再申请和获得任何其它封锁

也就是说在事务提交之前，事务中包含的sql语句涉及到的所有数据都会被此事务加锁，或加读锁，或加写锁；在事务提交时所做的工作之一就是释放所占有的锁。  

两段锁协议主要是为了解决单机事务中的一致性与隔离性。  

遵守两段锁协议的事务是可能发生死锁的。 **问题：mysql是如何解决事务死锁情况的呢？？？**    

#### 事务ACID特性  
1. 原子性： 通常来说，原子性就是指事务包含的一系列的操作，要么全部都执行，要么都不执行
2. 一致性：关系型数据库的一致性对事务一致性的要求包含两个层面，一是对数据完整性以及合法性的检查，比如对于外键参照完整性的检查等，二是要求开发者在代码中写出正确的事务逻辑
3. 隔离性：四个隔离级别，READ UNCOMMITED、READ COMMITED、REPEATABLE READ和SERIALIZABLE。
   **隔离性这里是涉及到对数据加锁的。**比如对于REPEATABLE READ的隔离级别。就要求在A事务中读取过的数据在A事务提交之前是不允许其他事务对其读过的数据做更改的。那这是怎么实现的呢？可以是对读过的数据加读共享锁，这样其他数据尝试获取此数据的写独占锁时就会失败。
4. 持久性：一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来。

对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。

**使用InnoDB事务控制时注意以下几点可以避免性能损失：**  
* 使用小事务  
* 选择合适的隔离级别(对于MySql InnoDB，由于MVCC的存在，Read Committed不一定比Repeatable Read的效率高，所以InnoDB引擎的默认隔离级别是Repeatable Read；不使用MVCC的话，Read Committed是要比Repeatable Read的效率高的，因为Read Committed对于读操作不需要加锁，而Repeatable Read是要加锁的)
* 保证事务是可以执行完成的
* 避免死锁


#### MVCC
一般MVCC有2种实现方法：
* 写新数据时，把旧数据转移到一个单独的地方，如回滚段中，其他人读数据时，从回滚段中把旧的数据读出来，如Oracle数据库和MySQL中的innodb引擎。
* 写新数据时，旧数据不删除，而是把新数据插入。PostgreSQL就是使用的这种实现方法。

两种方法各有利弊，相对于第一种来说，PostgreSQL的MVCC实现方式优缺点如下：

* 优点
无论事务进行了多少操作，事务回滚可以立即完成
数据可以进行很多更新，不必像Oracle和MySQL的Innodb引擎那样需要经常保证回滚段不会被用完，也不会像oracle数据库那样经常遇到“ORA-1555”错误的困扰
* 缺点
旧版本的数据需要清理。当然，PostgreSQL 9.x版本中已经增加了自动清理的辅助进程来定期清理
旧版本的数据可能会导致查询需要扫描的数据块增多，从而导致查询变慢

具体参考：[阿里数据库内核月报——PgSQL · 特性分析 · MVCC机制浅析](http://mysql.taobao.org/monthly/2017/10/01/)

**多版本控制(MVCC):** 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。  

**具体来说，InnoDB MVCC是通过这样一种方式来维持读取数据时事务之间数据的可见性：** 

**读操作：**
数据库需要做好版本控制，防止不该被事务看到的数据(例如还没提交的事务修改的数据)被看到。在InnoDB中，主要是通过使用readview的技术来实现判断。查询出来的每一行记录，都会用readview来判断一下当前这行是否可以被当前事务看到，如果可以，则输出，否则就利用undolog来构建历史版本，再进行判断，知道记录构建到最老的版本或者可见性条件满足。  

在内部，InnoDB为存储在数据库中的每一行添加三个字段。 6字节的DB_TRX_ID字段指示插入或更新该行的最后一个事务的事务标识符。 此外，删除在内部被视为更新，其中行中的特殊位被设置为将其标记为已删除。 每行还包含一个7字节的DB_ROLL_PTR字段，称为滚动指针。 滚动指针指向写入回滚段的撤消日志记录。 如果更新了行，则撤消日志记录包含在更新行之前重建行内容所需的信息。 6字节的DB_ROW_ID字段包含在插入新行时单调增加的行ID。 如果InnoDB自动生成聚簇索引，则索引包含行ID值。 否则，DB_ROW_ID列不会出现在任何索引中。  

回滚段中的撤消日志分为插入和更新undo log。 只在事务回滚中需要insert undo log，并且可以在事务提交后立即丢弃。 更新undo log也用于一致性读取，但只有在InnoDB没有分配快照的事务之后才能丢弃它们，在一致读取中可能需要更新undo log中的信息来构建早期版本的数据库行。

在trx_sys中，一直维护这一个全局的活跃的读写事务id(trx_sys->descriptors)，id按照从小到大排序，表示在某个时间点，数据库中所有的活跃(已经开始但还没提交)的读写(必须是读写事务，只读事务不包含在内)事务。当需要一个一致性读的时候(即创建新的readview时)，会把全局读写事务id拷贝一份到readview本地(read_view_t->descriptors)，当做当前事务的快照。read_view_t->up_limit_id是read_view_t->descriptors这数组中最小的值，read_view_t->low_limit_id是创建readview时的max_trx_id，即一定大于read_view_t->descriptors中的最大值。当查询出一条记录后(记录上有一个trx_id，表示这条记录最后被修改时的事务id)，可见性判断的逻辑如下(lock_clust_rec_cons_read_sees)：

如果记录上的trx_id小于read_view_t->up_limit_id，则说明这条记录的最后修改在readview创建之前，因此这条记录可以被看见。  

如果记录上的trx_id大于等于read_view_t->low_limit_id，则说明这条记录的最后修改在readview创建之后，因此这条记录肯定不可以被看见。  

如果记录上的trx_id在up_limit_id和low_limit_id之间，且trx_id在read_view_t->descriptors之中，则表示这条记录的最后修改是在readview创建之时，被另外一个活跃事务所修改，所以这条记录也不可以被看见。如果trx_id不在read_view_t->descriptors之中，则表示这条记录的最后修改在readview创建之前，所以可以看到。  

基于上述判断，如果记录不可见，则尝试使用undo去构建老的版本(row_vers_build_for_consistent_read)，直到找到可以被看见的记录或者解析完所有的undo。  

**写操作：**
* 事务以排他锁的形式修改原始数据
* 把修改前的数据存放于undo log，通过回滚指针与主数据关联
* 修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）

Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。  

比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。  

理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。  

[Mysql中的MVCC](https://blog.csdn.net/chen77716/article/details/6742128)

**问题：对于这种情况InnoDB MVCC实现是如何处理的？？？**
使用MySqlWorkbench开启两个数据库连接，每个连接中各开启一个数据库事务，亲测MySql MVCC体现效果如下(隔离级别为Repetable Read)：  
有一条原始数据值为1，事务一先于事务二开启：
* 情况1：事务1更新了这条数据值为2，不提交；事务2再尝试更新此条数据提示加锁失败，但是是可以读这条数据的。
* 情况2：事务1先读了这条数据，不提交；事务2更新这条数据为2，提交；之后事务1再读这条数据，结果仍为1，但是此时事务1对此条数据做更新操作却能意识到此数据的值已经改变，比如事务1通过update 表名 where value = 1 是找不到这条数据，无法对它更新的，只能通过update 表名 where value = 1 进行更新。
* 情况3：事务1先读这条数据，不提交；事务2删除这条数据，提交；事务1再读这条数据可以读到，但事务1的更新操作是可以意识到此行数据已经被删除了(更新语句会提示0 rows affect)。
* 情况4：事务1先开启事务，事务2后开启；之后事务2直接将这条数据删除，提交；事务1读到这条数据为null

**读读、读写、写读之间是不会阻塞的，写操作之间会阻塞，**比如事务1先于事务2开启，之后事务1更新了某条数据不提交，在事务1提交之前，所有在事务1之后开启的事务对此条数据的更新操作都会被阻塞，直到事务1提交为止。  

### 扩展MySql
1、通过将一个表的数据划分到多个mysql实例上实现，但需要自己掌握划分后的应用sql的访问逻辑。阿里云分布式关系型数据库DRDS。分布式关系数据库相比于单机上的mysql肯定会有一些查询语句不被支持，比如DRDS目前就不支持含有having子句的子查询。    
2、通过一主多备的方式实现容灾机制
3、通过ndb、innodb cluster方式扩展，这种最理想，动态扩容，不需要进行手动划分表等操作，对应用层最友好，不过实现起来也最难。  

MySqlInnoDB cluster解决的问题是HA高可用，会自动向集群的所有成员复制数据，同时提供容错、自动故障转移和弹性。也就是说集群中所有服务器存储的是重复的数据，解决的不是分库分表这种问题。  

而阿里云DRDS会根据建表语句中指定的分库分表策略自动将数据存储在相应的服务器中，不同服务器之间存储的数据是不重复的，解决了mysql扩容的问题。其解决的另一个问题是对应用层提供了透明的sql访问，应用层不需要知道真实数据到底存在哪个服务器上，限制是相比于使用单机使用mysql的方式，会有一些查询语句不被支持，比如DRDS目前就不支持含有having子句的子查询。      

类似于DRDS，mysql官方为了解决水平扩容的问题，也有MySql NDB Cluster的解决方案：

* MySQL Cluster只支持 NDB 存储引擎。也就是说，想要让一个表在集群节点中共享，就必须指定ENGINE=NDB(或 ENGINE=NDBCLUSTER 也一样)。

* MySQL集群中也可以使用MyISAM或InnoDB存储引擎来创建数据表，但是那些非NDB的表不会存储在集群节点间共享;它们独立于创建的MySQL服务器或者实例中。

但是NDB 是一个内存式存储引擎也就是说，他会将所有的数据和索引数据都load 到内存中(**这么搞的话ndb cluster不是很鸡肋，我数据有64T，难道就需要64T的内存空间吗？不能类似于innodb这种，在内存中加载索引，使用哪个数据的时候再去磁盘中查找吗？**)，但也会将数据持久化到存储设备上。不过，最新版本，已经支持用户自己选择数据可以不全部Load 到内存中了，这对于有些数据量太大或者基于成本考虑而没有足够内存空间来存放所有数据的用户来说的确是一个大好消息。  

### 数据库层面上的分布式事务
指的是数据库中数据太多，一个数据库存不完，在数据分布在多个主机上时如何保证数据库的事务操作仍然对应用层透明，这是一个很难解决的问题，Mysql的两阶段提交协议就是主要用于分布式事务而设计的。  



